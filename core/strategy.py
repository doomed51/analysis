"""
    Base class for analyzing various characteristics of a strategy defined by: 
    - a symbol : str of the underlying 
    - a signal : str column name of the signal generated by the strat 
    - a signal dataframe: pd.DataFrame containing a date, and signal column 
    - a target: str column name of what the singal is a function of  
    - a target dataframe : pd.DataFrame containing the col. being targeted by the signal 
"""
import config
import pandas as pd 
import seaborn as sns
from interface import interface_localDB as db

from utils import utils_strategyAnalyzer as sa

class Strategy:
    def __init__(self, name, symbol, interval='1day', signal_name='close'):
        self.name = name 
        self.symbol = symbol
        self.interval = interval
        self.signal_name = signal_name
        self.pxhistory = self._load_pxhistory(symbol=self.symbol, interval=self.interval)
        self._calc_zscore('close')
        

    ######### COLUMN CALCULATION FUNCTIONS 
    """"
        Behold, herein lie lambda functions generating the required calculated columns for the strategy  
    """

    def _calc_signal(self):
        """
            Define the signal calculation in the strategy implementation class 
        """
        print('ERROR: _calc_signal not implemented')
    
    def _calc_rolling_percentile_for_col(self, target_col_name = 'close', rollingWindow=252):
        self.pxhistory['%s_percentile'%(self.signal_name)] = self.pxhistory[target_col_name].rolling(rollingWindow).apply(lambda x: pd.qcut(x, 10, labels=False)[-1], raw=True) 
        self._calc_zscore('%s_percentile'%(self.signal_name))

    def _calc_zscore(self, colname, rollingWindow=252):
        self.pxhistory['%s_zscore'%(colname)] = self.pxhistory[colname].rolling(rollingWindow).apply(lambda x: (x[-1] - x.mean()) / x.std(), raw=True)

    ######### SECTION END 

    # load underlying history from db 
    def _load_pxhistory(self, symbol, interval):
        with db.sqlite_connection(config.dbname_stock) as conn:
            return db.getPriceHistory(conn, self.symbol, self.interval)
        
    
    ######### PLOTTING FUNCTIONS
    """"
        Behold, herein lie generic plotting functions. They draw plots on the provided axis.  
    """

    # draw distribution of passed in column name (x) 
    def draw_distribution(self, ax, y='close', drawPercetiles=True, **kwargs):
            bins = kwargs.get('bins', 50)
            percentiles_to_plot = kwargs.get('percentiles_to_plot', [0.01, 0.05, 0.1, 0.5, 0.9, 0.95, 0.99])
            # set title
            ax.set_title('Distribution of %s'%(y), fontsize=14, fontweight='bold')

            # plot the histogram of the signal 
            sns.histplot(self.pxhistory[y], ax=ax, kde=True, bins=bins)
            if drawPercetiles:
                for p in percentiles_to_plot:
                    ax.axvline(self.pxhistory[y].quantile(p), color='grey', linestyle='--', alpha=0.5)
                    ax.text(self.pxhistory[y].quantile(p), ax.get_ylim()[1], '%.2fth: %.5f'%(p*100, round(self.pxhistory[y].quantile(p), 5)), fontsize=11, rotation=90, verticalalignment='top', color='grey', alpha=0.7)
            
            # plot last value of signal 
            ax.axvline(self.pxhistory[y].iloc[-1], color='red', linestyle='--', alpha=0.5)
            ax.text(self.pxhistory[y].iloc[-1], ax.get_ylim()[1], 'Last: %.5f'%(self.pxhistory[y].iloc[-1]), fontsize=11, rotation=90, verticalalignment='top', color='red', alpha=0.7)

            # additional plot formatting
            ax.grid(True, which='both', axis='both', linestyle='-', alpha=0.2)
            ax.set_ylabel('count')
            ax.set_xlabel(y)

    # draw a lineplot of column y, with optional second plot of column y_alt on a different scale. On the plot, display a range of percentiles e.g. [.01, .05, 0.5, 0.95, 0.99] of y
    def draw_lineplot(self, ax, y='close', y_alt=None, **kwargs):
        includePercentiles = kwargs.get('includePercentiles', False)
        includePercentiles_y_alt = kwargs.get('includePercentiles_x_alt', False)
        percentiles_to_plot = kwargs.get('percentiles_to_plot', [0.01, 0.05, 0.1, 0.5, 0.9, 0.95, 0.99])
        percentile_source = kwargs.get('percentile_source', y) #Use any col as source for percentiles
        n_periods_to_plot = kwargs.get('n_periods_to_plot', 0)

        if n_periods_to_plot>0:
            _pxhistory = self.pxhistory.tail(n_periods_to_plot)
        else:
            _pxhistory = self.pxhistory

        ax.set_title('Lineplot of %s'%(y), fontsize=14, fontweight='bold')
        sns.lineplot(x=_pxhistory['date'], y=_pxhistory[y], ax=ax)
        if y_alt:
            ax2 = ax.twinx()
            sns.lineplot(x=_pxhistory['date'], y=_pxhistory[y_alt], ax=ax2, color='g', alpha=0.5)
        
        if includePercentiles:
            for p in percentiles_to_plot:
                ax.axhline(_pxhistory[percentile_source].quantile(p), color='grey', linestyle='--', alpha=0.3)
            # add labels as yticks 
            ax.set_yticks([_pxhistory[percentile_source].quantile(p) for p in percentiles_to_plot])
            ax.set_yticklabels(['Percentile %.2d\n%.5f'%(p*100, round(_pxhistory[percentile_source].quantile(p), 5)) for p in percentiles_to_plot], fontsize=10, rotation=0, verticalalignment='top', color='grey', horizontalalignment='right')

        elif includePercentiles_y_alt:
            for p in percentiles_to_plot:
                ax2.axhline(_pxhistory[percentile_source].quantile(p), color='red', linestyle='--', alpha=0.3)
            # add labels as yticks
            ax2.set_yticks([_pxhistory[percentile_source].quantile(p) for p in percentiles_to_plot])
            ax2.set_yticklabels(['Percentile %.2d: %.5f'%(p*100, round(_pxhistory[percentile_source].quantile(p), 5)) for p in percentiles_to_plot], fontsize=10, rotation=0, verticalalignment='top', color='red')

        # plot formattting 
        ax.grid(True, which='both', axis='both', linestyle='-', alpha=0.2)
        ax.set_ylabel(y)
        ax.set_xlabel('date')
